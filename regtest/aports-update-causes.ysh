#!bin/ysh
#
# Generate a new report, based on the latest report available.
# Used to update causes in a report without rebuilding any packages.
# 
# Example usage:
#   regtest/aports-update-causes.sh update-latest main # generate new report for main
#   regtest/aports-update-causes.sh update-latest community # generate new report for community

const REPORTS_PATH="_tmp/aports-report"
  
func useMainReports(kind) {
  if(kind === 'main') {
    return (true)
  }
  return (false)
}

func useCommunityReports(kind) {
  if (kind === 'community') {
    return (true)
  }
  return (false)
}

func calculateNewEpoch(use_main) {
  var new_epoch = $(date +%Y-%m-%d)
  if (use_main === false) {
    setvar new_epoch = new_epoch ++ "-comm"
  }
  return (new_epoch ++ "-cause")
}

proc rename-editing-epoch(new_epoch) {
  var pattern = / u'readonly EDITING_APORTS_EPOCH=\'' dot* /
  var new_value = u'readonly EDITING_APORTS_EPOCH=\'' ++ new_epoch ++ u'.wwz\''
  sed -i -E "s/$pattern/$new_value/" regtest/aports-html.sh
}

proc download-report(epoch) {
  rename-editing-epoch "$epoch"

  regtest/aports-html.sh sync-old-wwz
}

proc prepare-new-report(original_epoch, new_epoch, use_main) {
  regtest/aports-html.sh extract-old-wwz $new_epoch
}

proc generate-new-report(new_epoch, use_main) {
  # assuming runs from main are full runs and from community partial
  # this might break, should probably find a better way to do this
  # Maybe check contents of _tmp/aports-report/$original_epoch?
  # Could check if all shards are present maybe?
  if (use_main === 'true') {
    regtest/aports-html.sh write-all-reports "_tmp/aports-report/$new_epoch"
  } else {
    regtest/aports-html.sh write-disagree-reports "_tmp/aports-report/$new_epoch"
  }
}

proc deploy-new-report(new_epoch) {
  regtest/aports-html.sh make-wwz "_tmp/aports-report/$new_epoch"
  regtest/aports-html.sh deploy-wwz-op "_tmp/aports-report/$new_epoch.wwz"
}

proc update-latest() {
  ### Create a new report based on the most recent published report
  ### Create the new report using a newer `causes.awk` file
  ### Does the following steps:
  ### 1. Fetch base report that is to be updated
  ### 2. Generate new report using new causes.awk based on report from step 1
  ### 3. Write new report
  ###
  ### Current limitations:
  ### Assumes community runs are partial runs, and main runs are full.
  ### If this is not true the script breaks
  set -x

  # TODO: can these be passed from soil anyway maybe?
  # Maybe through soil/worker.sh?
  var original_epoch = ENV.REGTEST_CAUSES_BASE_REPORT
  var kind = ENV.REGTEST_CAUSES_KIND
  
  var use_main = useMainReports(kind)
  if (use_main === false and useCommunityReports(kind) === false) {
    echo "kind should be main or community, got: $kind"
    exit 1
  }

  var new_epoch = calculateNewEpoch(use_main)

  echo "Generating new report with epoch $new_epoch based on $original_epoch for $kind"

  download-report $original_epoch
  
  prepare-new-report $original_epoch $new_epoch $use_main

  generate-new-report $new_epoch $use_main

  deploy-new-report $new_epoch

  echo "New report available at: https://op.oils.pub/aports-build/$new_epoch.wwz/_tmp/aports-report/$new_epoch/diff_merged.html"
}

runproc @ARGV
