"""visitor.py."""
from __future__ import print_function

import sys
from asdl import ast
from typing import List, IO


class AsdlVisitor:
    """Tree walker base class.

    This is NOT a visitor, since it doesn't have accept(self) and double
    dispatch.

    VisitModule uses the "template method pattern" 
        https://en.wikipedia.org/wiki/Template_method_pattern
    """

    def __init__(self, f):
        # type: (IO[bytes]) -> None
        self.f = f
        self.current_depth = 0  # the current number of indent levels

    def Indent(self):
        # type: () -> None
        self.current_depth += 1

    def Dedent(self):
        # type: () -> None
        self.current_depth -= 1

    def Emit(self, s, depth=-1, reflow=True):
        # type: (str, int, bool) -> None
        if depth == -1:
            depth = self.current_depth
        for line in FormatLines(s, depth, reflow=reflow):
            self.f.write(line)

    def VisitModule(self, mod, depth=0):
        # type: (ast.Module, int) -> None
        """
        Template method
        """
        self.EmitHeader(mod)

        for dfn in mod.dfns:
            if isinstance(dfn, ast.SubTypeDecl):
                self.VisitSubType(dfn)

            elif isinstance(dfn, ast.TypeDecl):
                typ = dfn
                if isinstance(typ.value, ast.SimpleSum):
                    self.VisitSimpleSum(typ.value, typ.name, depth)

                elif isinstance(typ.value, ast.Sum):
                    self.VisitCompoundSum(typ.value, typ.name, depth)

                elif isinstance(typ.value, ast.Product):
                    self.VisitProduct(typ.value, typ.name, depth)

                else:
                    raise AssertionError(typ)

            else:
                raise AssertionError(dfn)

        self.EmitFooter()

    def VisitSubType(self, subtype):
        # type: (ast.SubTypeDecl) -> None
        pass

    # Optionally overridden.
    def VisitSimpleSum(self, value, name, depth):
        # type: (ast.SimpleSum, str, int) -> None
        pass

    def VisitCompoundSum(self, value, name, depth):
        # type: (ast.Sum, str, int) -> None
        pass

    def VisitProduct(self, value, name, depth):
        # type: (ast.Product, str, int) -> None
        pass

    def EmitHeader(self, schema_ast):
        # type: (ast.Module) -> None
        pass

    def EmitFooter(self):
        # type: () -> None
        pass


TABSIZE = 2
MAX_COL = 80

# Copied from asdl_c.py


def _ReflowLines(s, depth):
    # type: (str, int) -> List[str]
    """Reflow the line s indented depth tabs.

    Return a sequence of lines where no line extends beyond MAX_COL when
    properly indented.  The first line is properly indented based
    exclusively on depth * TABSIZE.  All following lines -- these are
    the reflowed lines generated by this function -- start at the same
    column as the first character beyond the opening { in the first
    line.
    """
    size = MAX_COL - depth * TABSIZE
    if len(s) < size:
        return [s]

    lines = []
    cur = s
    padding = ""
    while len(cur) > size:
        i = cur.rfind(' ', 0, size)
        if i == -1:
            if 0:
                print(
                    "Warning: No space to reflow line (size=%d, depth=%d, cur=%r): %r"
                    % (size, depth, cur, s),
                    file=sys.stderr)
            lines.append(padding + cur)
            break

        lines.append(padding + cur[:i])
        if len(lines) == 1:
            # find new size based on brace
            j = cur.find('{', 0, i)
            if j >= 0:
                j += 2  # account for the brace and the space after it
                size -= j
                padding = " " * j
            else:
                j = cur.find('(', 0, i)
                if j >= 0:
                    j += 1  # account for the paren (no space after it)
                    size -= j
                    padding = " " * j
        cur = cur[i + 1:]
    else:
        lines.append(padding + cur)
    return lines


def FormatLines(s, depth, reflow=True):
    # type: (str, int, bool) -> List[str]
    """Make the generated code readable.

    Args:
      depth: controls indentation
      reflow: line wrapping.
    """
    if reflow:
        lines = _ReflowLines(s, depth)
    else:
        lines = [s]

    result = []
    for line in lines:
        line = (" " * TABSIZE * depth) + line + "\n"
        result.append(line)
    return result


"""
For */*_gen.py, and asdl/gen_*.py

from asdl.util import Write

def f():
    # constant string with leading stuff stripped off
    Write(f, '''
        hello
        there
       |''')

    # - option to reflow
    # - option to add MORE depth, in addition to stripping whitespace
    #   - I wonder if YSH template strings could use something like that
    Write(f, '''
        a = {a}
        b = {b}
       |''', locals(), reflow=True, depth=2)

    with Printer(locals()) as p:
      p.Write('''
          a = {a}
          b = {b}
         |''')
"""
