#!/usr/bin/env python2
"""
NINJA_config.py
"""
from __future__ import print_function

import os
import sys

# NOTE: Keep these in sync with NINJA_GRAPH_FILES below.
from cpp import NINJA_subgraph as cpp_subgraph
from mycpp import NINJA_subgraph as mycpp_subgraph

sys.path.append('.')
from vendor import ninja_syntax


def log(msg, *args):
  if args:
    msg = msg % args
  print(msg, file=sys.stderr)


# The files that together define the ninja build graph. It's important that
# these are accurate in order for ninja to detect when the build description is
# out of date.
NINJA_GRAPH_FILES = ['NINJA-config.sh',
                     'NINJA_config.py',
                     'cpp/NINJA_subgraph.py',
                     'mycpp/NINJA_subgraph.py']

# The file Ninja runs by default.
BUILD_NINJA = 'build.ninja'


def main(argv):
  try:
    action = argv[1]
  except IndexError:
    action = 'ninja'

  if action == 'ninja':
    n = ninja_syntax.Writer(open(BUILD_NINJA, 'w'))

    # Add a rule for re-running NINJA-config.sh whenever any of the generator
    # scripts change.
    n.comment('Regenerate ninja files')
    n.comment('Generated by %s.' % __name__)
    n.newline()

    n.rule('NINJA-config',
           command='./NINJA-config.sh',
           pool='console',
           description='Regenerating ninja files')
    n.newline()

    n.build(BUILD_NINJA,
            implicit=NINJA_GRAPH_FILES,
            rule='NINJA-config',
            variables={'generator': '1'})
    n.newline()

    cpp_subgraph.NinjaGraph(n)

    n.newline()
    n.newline()

    mycpp_subgraph.NinjaGraph(n)

    log('%s: Wrote %s', argv[0], BUILD_NINJA)


  elif action == 'shell':
    out = '_build/oil-native.sh'
    with open(out, 'w') as f:
      cpp_subgraph.ShellFunctions(f, argv[0])
    log('%s: Wrote %s', argv[0], out)

  else:
    raise RuntimeError('Invalid action %r' % action)


if __name__ == '__main__':
  try:
    main(sys.argv)
  except RuntimeError as e:
    print('FATAL: %s' % e, file=sys.stderr)
    sys.exit(1)
