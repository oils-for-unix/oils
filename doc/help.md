---
in_progress: yes
css_files: ../web/base.css ../web/manual.css ../web/help.css ../web/toc.css
body_css_class: width40 help-body
---

Oil Help
========

<!--
IMPORTANT: This doc is processed in TWO WAYS.  Be careful when editing.

To generate HTML:
- split_doc.py and then devtools/cmark.py

To generate text for bin/oil
- 'devtools/cmark.py' to render HTML, then 'make_help.py cards' to generate
  'card' files.

Subset of Markdown we use:
- **bold** for bold (italic doesn't work)
- `backticks` to generate <code> (ANSI: reverse?)
- [links] to generate <a href=""></a> (ANSI underline: then add to bottom?)
- 4 space indents  to generate <pre><code>
- fenced code blocks to generate <pre><code class="language-X">
  - we COULD syntax highlight now.  At least the comments and strings?

Note: <p> implies word wrapping!
  well that's good because then you can do it dynamically.
  note: Python has textwrap!

-->

This doc describes every aspect of Oil and OSH briefly, and is indexed by
keywords.

The `help` builtin prints portions of it.

You can also navigate this doc with the [help index](help-index.html).

<!--
TODO:

- <h4> also needs anchors generated
  - but not in TOC

- cross ref bash?  <a href="$:bash"></a>
  - links appear below the card?

- Check that the cards don't go over 80 chars

- Have a way to mark cards as DEPRECATED
  - dparen ((
  - <h4 deprecated=true>dparen ((</h4>
  - <h4 class="deprecated">dparen ((</h4>
    - well this is not in the TOC.  But the heading itself should be GREY
      instead of BLUE
    - but what about in the quick-ref-index?  Can we somehow mark it there?

help cmd vars

h2: groups (of sections)
h3: sections
h4: topic/cards

<h2 tag="cmd"></h2>

- And then on the web display them SIDE BY SIDE
- At least two columns, maybe THREE!
- Display mobile CSS

_devbuild/gen/quick-ref should just have a flat list of IDs then?
or maybe <div class="card" id="foo"></div> can override the default <h4>
processing?

- h2 and h4 have explicit #anchor
- h3 has autogenerated anchor, with #Operators, etc.
  - or actually you could have Usage -> Command Line usage
-->


<div id="toc">
</div>

<h2 id="overview">Overview</h2>

### Usage

This section describes how to use the Oil binary.

<h4 id="osh-usage"><code>bin/osh</code> Usage</h4>

    Usage: osh [OPTION]... SCRIPT [ARG]...
           osh [OPTION]... -c COMMAND [ARG]...

The command line accepted by `bin/osh` is compatible with `/bin/sh` and `bash`.

    osh -c 'echo hi'
    osh myscript.sh
    echo 'echo hi' | osh

It also has a few enhancements:

    osh -n -c 'hello'                    # pretty-print the AST
    osh --ast-format text -n -c 'hello'  # print it full

osh accepts POSIX sh flags, with these additions:

  -n             parse the program but don't execute it.  Print the AST.
  --ast-format   what format the AST should be in

<h4 id="oil-usage"><code>bin/oil</code> Usage</h4>

    Usage: oil  [OPTION]... SCRIPT [ARG]...
           oil [OPTION]... -c COMMAND [ARG]...

`bin/oil` is the same as `bin/osh` with a the `oil:all` option group set.  So
`bin/oil` also accepts shell flags.

    oil -c 'echo hi'
    oil myscript.oil
    echo 'echo hi' | oil

<h4 id="bundle-usage">App Bundle Usage</h4>

    Usage: oil.ovm MAIN_NAME [ARG]...
           MAIN_NAME [ARG]...

oil.ovm behaves like busybox.  If it's invoked through a symlink, e.g. 'osh',
then it behaves like that binary.  Otherwise the binary name can be passed as
the first argument, e.g.:

    oil.ovm osh -c 'echo hi'

<h4 id="config">Configuring the Shell</h4>

If the --rcfile flag is specified, that file will be executed on startup.
Otherwise:

- `bin/osh` runs `~/.config/oil/oshrc`
- `bin/oil` runs `~/.config/oil/oilrc`

Pass --rcfile /dev/null to disable this behavior.

<h4 id="config">Startup Files</h4>

History is read?


<h3>Lexing</h3>

<h4 id="comments">comments</h4>

A comment starts with `#` and goes until the end of the line.

    echo hi  # print a greeting

<h4 id="line-continuation">line-continuation</h4>

A backslash `\` at the end of a line continues the line without executing it:

    ls /usr/bin \
       /usr/lib \
       ~/src        # A single command split over three lines

<h3>Oil Lexing</h3>


<h4 id="single-command">single-command</h4>

The %%% prefix Starts a Single Command Over Multiple Lines (?)

This special lexer mode has several use cases:

Long command lines without trailing \

    %%% chromium-browser
        --no-proxy-server
        # comments allowed
        --incognito

Long pipelines or and-or chains without trailing \ 

    %%% find .
        # exclude tests
      | grep -v '_test.py'
      | xargs wc -l
      | sort -n

    %%% ls /
     && ls /bin
     && ls /lib
     || error "oops"

<h4 id="docstring">docstring</h4>

TODO

<h2 id="command">Command Language</h2>

### Commands

<h4 id="simple-command">simple-command</h4>

Commands are composed of words.  The first word may by the name of a shell
builtin, an Oil proc / shell "function", an external command, or an alias:

    echo hi               # a shell builtin doesn't start a process
    ls /usr/bin ~/src     # starts a new process
    myproc "hello $name"
    myshellfunc "hello $name"
    myalias -l
<!-- TODO: document lookup order -->

Redirects are also allowed in any part of the command:

    echo 'to stderr' >&2
    echo >&2 'to stderr'

    echo 'to file' > out.txt
    echo > out.txt 'to file'

<h4 id="semicolon">semicolon ;</h4>

Run two commands in sequence like this:

    echo one; echo two

or this:

    echo one
    echo two

<h3>Conditional</h3>

<h4 id="case">case</h4>

Match a string against a series of glob patterns.  Execute code in the section
below the matching pattern.

    path='foo.py'
    case "$path" in
      *.py)
        echo 'python'
        ;;
      *.sh)
        echo 'shell'
        ;;
    esac

<h4 id="if">if</h4>

Test if a command exited with status zero (true).  If so, execute the
corresponding block of code.

Shell:

    if test -d foo; then
      echo 'foo is a directory'
    elif test -f foo; then
      echo 'foo is a file'
    else
      echo 'neither'
    fi

Oil:

    if test -d foo {
      echo 'foo is a directory'
    } elif test -f foo {
      echo 'foo is a file'
    } else {
      echo 'neither'
    }

<h4 id="true">true</h4>

Do nothing and return status 0.

    if true; then
      echo hello
    fi

<h4 id="false">false</h4>

Do nothing and return status 1.

    if false; then
      echo 'not reached'
    else
      echo hello
    fi

<h3>Iteration</h3>

### Control Flow

### Grouping

### Concurrency

### Redirects

#### redir-file

Three variants of redirecting stdout:

    echo foo > out.txt    # write to a file
    echo foo >> out.txt   # append to a file
    echo foo >| out.txt   # clobber the file even if set -o noclobber

Redirect stdin:

    cat < in.txt

<!-- They also take a file descriptor on the left -->


#### redir-desc

Redirect to a file descriptor:

    echo 'to stderr' >&2

<!--
NOTE: >&2 is just like <&2 
There's no real difference.
-->

#### here-doc

    cat &lt;&lt;EOF
    here doc with $double ${quoted} substitution
    EOF

    myfunc() {
            cat &lt;&lt;-EOF
            here doc with one tab leading tab stripped
            EOF
    }

    cat <<< 'here string'

<!-- TODO: delimiter can be quoted -->
<!-- Note: Python's HTML parser thinks <EOF starts a tag -->

### Other Command

<h4 id="dparen">dparen ((</h4>

<h4>time</h4>

`time [-p] pipeline`

Measures the time taken by a command / pipeline.  It uses the `getrusage()`
function from `libc`.

Note that time is a KEYWORD, not a builtin!

<!-- Note: bash respects TIMEFORMAT -->

<h3>Oil Keywords</h3>

### Coil Keywords

<h2 id="assign">Assigning Variables</h2>

### Operators

### Compound Data

### Builtins

### Oil Keywords

<!-- CONFLICT: This duplicates the above -->

<h2 id="expr">Oil Expression Language</h2>

### Data Types

### Operators

<!-- CONFLICT: This duplicates the above -->

### Functions

### Regexes

<h2 id="word">Word Language</h2>

### Quotes

### Substitutions

<h3>Var Ops</h3>

<h4 id="op-format">op-format</h4>

${x@P} evaluates x as a prompt string, e.g. the string that would be printed if
PS1=$x.


<h3>Oil Word</h3>

<h2 id="sublang">Other Shell Sublanguages</h2>

### Arithmetic

### Boolean

### Patterns

### Brace Expand

### History

<h2 id="builtin">Builtin Commands</h2>

### I/O

These builtins take input and output.  They're often used with redirects.

### Run Code

### Set Options

### Working Dir

### Completion

<h4 id="complete">complete</h4>

Register completion policies for different commands.

<h4 id="compgen">compgen</h4>

Generate completion candidates inside a user-defined completion function.

It can also be used in scripts, i.e. outside a completion function.

<h4 id="compopt">compopt</h4>

Change completion options inside a user-defined completion function.

<h4 id="compadjust">compadjust</h4>

Adjust COMP_ARGV according to specified delimiters, and optionally set
variables cur, prev, words (an array), and cword.  May also set 'split'.

This is an OSH extension that makes it easier to run the bash-completion
project.

<h3>Shell Process</h3>
                
### Child Process

### External

<h4 id="kill">kill</h4>

TODO

<!-- bash accepts job control syntax -->

<h4 id="enable">enable</h4>

Bash has this, but OSH won't implement it.

<h3>Introspection</h3>

<h4 id="help">help</h4>

    help index           # list all help topics
    help index GROUP...  # list help topics in the given groups
    help TOPIC           # show help on a given topic
    help osh-usage       # same as osh --help
    help oil-usage       # same as oil --help

View on the web: http://www.oilshell.org/$VERSION/doc/osh-quick-ref.html

<h3>Word Lookup</h3>

### Interactive

### Oil Builtins

<h2 id="option">Shell Options</h2>

### Errors

### Globbing

### Debugging

### Interactive

### Other Option

### strict:all

### oil:basic

### oil:all

<h2 id="env">Environment Variables</h2>

### Shell Options

<!-- CONFLICT: Duplicates the above -->

<h4 id="SHELLOPTS">SHELLOPTS</h4>

For the 'set' builtin.

<h4 id="BASHOPTS">BASHOPTS</h4>

For the 'shopt' builtin.

<h3>Other Env</h3>

<h4 id="HOME">HOME</h4>

$HOME is used for:

1. ~ expansion 
2. ~ abbreviation in the UI (the dirs builtin, \W in $PS1).

Note: The shell doesn't set $HOME.  According to POSIX, the program that
invokes the login shell sets it based on /etc/passwd.

<h4 id="PATH">PATH</h4>

A colon-separated string that's used to find executables to run.

<h4 id="IFS">IFS</h4>

Used for word splitting.  And the builtin split() function.

<h3>Oil Paths</h3>

<h2 id="special">Special Variables</h2>

### Special

### POSIX Special

### Other Special

### Oil Special

### Platform

### Call Stack

### Tracing

### Process State

### Process Stack

### Shell State

<h3>Completion</h3>

<h4 id="COMP_WORDS">COMP_WORDS</h4>

An array of words, split by : and = for compatibility with bash.  New
completion scripts should use COMP_ARGV instead.

<h4 id="COMP_CWORD">COMP_CWORD</h4>

Discouraged; for compatibility with bash.

<h4 id="COMP_LINE">COMP_LINE</h4>

Discouraged; for compatibility with bash.

<h4 id="COMP_POINT">COMP_POINT</h4>

Discouraged; for compatibility with bash.

<h4 id="COMPREPLY">COMPREPLY</h4>

User-defined completion functions should Fill this array with candidates.  It
is cleared on every completion request.

<h4 id="COMP_ARGV">COMP_ARGV</h4>

An array of partial command arguments to complete.  Preferred over COMP_WORDS.
The compadjust builtin uses this variable.

(An OSH extension to bash.)

<h3>Functions</h3>


### Other Special

<h2 id="plugin">Plugins and Hooks</h2>

### Signals

### Traps

<h3>Words</h3>

<h4 id="PS1">PS1</h4>

First line of a prompt.

<h4 id="PS2">PS2</h4>

Second line of a prompt.

<h4 id="PS3">PS3</h4>

For the 'select' builtin (unimplemented).

<h4 id="PS4">PS4</h4>

For 'set -o xtrace'.  The leading character is special.

<h3>Completion</h3>

### Other Plugin

<h2 id="lib">Oil Libraries</h2>

### Collections

`len()`

- `len(mystr)` is its length in bytes
- `len(myarray)` is the number of elements
- `len(assocarray)` is the number of pairs

`copy()`:

```
var d = {name: value}

var alias = d  # illegal, because it can create ownership problems
               # reference cycles
var new = copy(d)  # valid
```

### Pattern

- `regmatch(/d+/, s)` returns a match object
- `fnmatch('*.py', s)`  returns a boolean

### String

### Better Syntax

These functions give better syntax to existing shell constructs.

- `shquote()` for `printf %q` and `${x@Q}`
- `lstrip()` for `${x#prefix}` and  `${x##prefix}`
- `rstrip()` for `${x%suffix}` and  `${x%%suffix} 
- `lstripglob()` and `rstripglob()` for slow, legacy glob
- `upper()` for `${x^^}
- `lower()` for `${x,,}
- `strftime()`: hidden in `printf`

### Arrays

- `index(A, item)` is like the awk function

### Assoc Arrays

- `@names()`
- `values()`.  Problem: these aren't all strings?

### Block

<h3>libc</h3>

<h4 id="strftime">strftime()</h4>

Useful for logging callbacks.  NOTE: bash has this with the obscure printf
'%(...)' syntax.

### Hashing

