"""
prebuilt/NINJA_subgraph.py
"""

from __future__ import print_function

import subprocess

from build.ninja_lib import log

_ = log


def NinjaGraph(ru):

    ru.comment('Generated by %s' % __name__)

    # These files are checked in.  See prebuilt/translate.sh includes

    # TODO: Because of J8 notation, prebuilt/translate.sh will
    # include
    #
    #    data_lang/j8_lite.py
    #
    # And then it calls:
    #
    #    fastfunc.J8EncodeString()
    #    match.CanOmitQuotes() or fastlex.CanOmitQuotes()
    #
    # So that means that we need may want a cc_library()
    #   data_lang/j8_lite_deps
    #
    # That includes both
    #
    #   //data_lang/j8  # header only C library
    #   //pyext/fastfunc
    #   //cpp/frontend_match  or //pyext/fastlex
    #
    # So prebuilt/ and oils-for-unix depend on //data_lang/j8_lite
    # That makes sense
    #
    # or maybe it's pyext/j8_lite_deps.{h,cc}
    # That kind makes sense
    #
    # And is it OK for the main binary to depend on that?
    # The problem is that you will pull in TWO COPIES of the huge match.asdl.h
    # header
    # This can bloat the binary size.  But it will be mostly unused.

    ru.cc_library(
        '//prebuilt/asdl/runtime.mycpp',
        srcs=['prebuilt/asdl/runtime.mycpp.cc'],
        deps=[
            '//asdl/hnode.asdl',
            '//cpp/data_lang',  # for fastfunc
        ])

    ru.cc_library(
        '//prebuilt/core/error.mycpp',
        srcs=['prebuilt/core/error.mycpp.cc'],
        deps=[
            '//asdl/hnode.asdl',
            '//core/value.asdl',
            '//frontend/syntax.asdl',
            '//cpp/data_lang',  # for fastfunc
        ])

    ru.cc_library(
        '//prebuilt/frontend/args.mycpp',
        srcs=['prebuilt/frontend/args.mycpp.cc'],
        deps=[
            '//asdl/hnode.asdl',
            '//core/runtime.asdl',
            '//frontend/syntax.asdl',
            '//cpp/data_lang',  # for fastfunc
            '//cpp/frontend_flag_spec',
        ])

    # NOTE: To avoid failures on these in CI, these targets are only enabled if
    # the user has the souffle executable in their PATH.
    if subprocess.call('which souffle > /dev/null', shell=True) == 0:
        ru.souffle_cpp('mycpp/datalog/call-graph.dl')
        ru.souffle_cpp('deps/source.medo/souffle/smoke-test.dl')
