// prebuilt/frontend/args.mycpp.h: GENERATED by mycpp

#ifndef FRONTEND_ARGS_MYCPP_H
#define FRONTEND_ARGS_MYCPP_H

#include "_gen/asdl/hnode.asdl.h"
#include "cpp/qsn.h"
#include "mycpp/runtime.h"

#include "_gen/core/runtime.asdl.h"
#include "_gen/frontend/syntax.asdl.h"
#include "cpp/frontend_flag_spec.h"
namespace runtime {  // forward declare


}  // forward declare namespace runtime

namespace format {  // forward declare

  class ColorOutput;
  class TextOutput;
  class HtmlOutput;
  class AnsiOutput;
  class _PrettyPrinter;

}  // forward declare namespace format

namespace pyerror {  // forward declare


}  // forward declare namespace pyerror

namespace args {  // forward declare

  class _Attributes;
  class Reader;
  class _Action;
  class _ArgAction;
  class SetToInt;
  class SetToFloat;
  class SetToString;
  class SetAttachedBool;
  class SetToTrue;
  class SetOption;
  class SetNamedOption;
  class SetAction;
  class SetNamedAction;

}  // forward declare namespace args

namespace runtime {  // declare

extern int NO_SPID;
hnode_asdl::hnode__Record* NewRecord(Str* node_type);
hnode_asdl::hnode__Leaf* NewLeaf(Str* s, hnode_asdl::color_t e_color);
extern Str* TRUE_STR;
extern Str* FALSE_STR;


}  // declare namespace runtime

namespace format {  // declare

format::ColorOutput* DetectConsoleOutput(mylib::Writer* f);
class ColorOutput {
 public:
  ColorOutput(mylib::Writer* f);
  virtual format::ColorOutput* NewTempBuffer();
  virtual void FileHeader();
  virtual void FileFooter();
  virtual void PushColor(hnode_asdl::color_t e_color);
  virtual void PopColor();
  virtual void write(Str* s);
  void WriteRaw(Tuple2<Str*, int>* raw);
  int NumChars();
  Tuple2<Str*, int> GetRaw();

  GC_OBJ(header_);
  mylib::Writer* f;
  int num_chars;
  
  static constexpr uint16_t field_mask() {
    return maskbit_v(offsetof(ColorOutput, f));
  }

  static constexpr ObjHeader obj_header() {
    return ObjHeader::ClassFixed(field_mask(), sizeof(ColorOutput));
  }

  DISALLOW_COPY_AND_ASSIGN(ColorOutput)
};

class TextOutput : public ColorOutput {
 public:
  TextOutput(mylib::Writer* f);
  virtual format::TextOutput* NewTempBuffer();
  virtual void PushColor(hnode_asdl::color_t e_color);
  virtual void PopColor();

  static constexpr ObjHeader obj_header() {
    return ObjHeader::ClassFixed(kZeroMask, sizeof(TextOutput));
  }

  DISALLOW_COPY_AND_ASSIGN(TextOutput)
};

class HtmlOutput : public ColorOutput {
 public:
  HtmlOutput(mylib::Writer* f);
  virtual format::HtmlOutput* NewTempBuffer();
  virtual void FileHeader();
  virtual void FileFooter();
  virtual void PushColor(hnode_asdl::color_t e_color);
  virtual void PopColor();
  virtual void write(Str* s);

  static constexpr ObjHeader obj_header() {
    return ObjHeader::ClassFixed(kZeroMask, sizeof(HtmlOutput));
  }

  DISALLOW_COPY_AND_ASSIGN(HtmlOutput)
};

class AnsiOutput : public ColorOutput {
 public:
  AnsiOutput(mylib::Writer* f);
  virtual format::AnsiOutput* NewTempBuffer();
  virtual void PushColor(hnode_asdl::color_t e_color);
  virtual void PopColor();

  static constexpr ObjHeader obj_header() {
    return ObjHeader::ClassFixed(kZeroMask, sizeof(AnsiOutput));
  }

  DISALLOW_COPY_AND_ASSIGN(AnsiOutput)
};

extern int INDENT;
class _PrettyPrinter {
 public:
  _PrettyPrinter(int max_col);
  bool _PrintWrappedArray(List<hnode_asdl::hnode_t*>* array, int prefix_len, format::ColorOutput* f, int indent);
  bool _PrintWholeArray(List<hnode_asdl::hnode_t*>* array, int prefix_len, format::ColorOutput* f, int indent);
  void _PrintRecord(hnode_asdl::hnode__Record* node, format::ColorOutput* f, int indent);
  void PrintNode(hnode_asdl::hnode_t* node, format::ColorOutput* f, int indent);

  GC_OBJ(header_);
  int max_col;

  static constexpr ObjHeader obj_header() {
    return ObjHeader::ClassScanned(0, sizeof(_PrettyPrinter));
  }

  DISALLOW_COPY_AND_ASSIGN(_PrettyPrinter)
};

bool _TrySingleLineObj(hnode_asdl::hnode__Record* node, format::ColorOutput* f, int max_chars);
bool _TrySingleLine(hnode_asdl::hnode_t* node, format::ColorOutput* f, int max_chars);
void PrintTree(hnode_asdl::hnode_t* node, format::ColorOutput* f);


}  // declare namespace format

namespace pyerror {  // declare

extern int NO_SPID;
[[noreturn]] void e_usage(Str* msg, int span_id = NO_SPID);
[[noreturn]] void e_strict(Str* msg, syntax_asdl::loc_t* location);
[[noreturn]] void p_die(Str* msg, syntax_asdl::loc_t* location);
[[noreturn]] void e_die(Str* msg, syntax_asdl::loc_t* location = nullptr);
[[noreturn]] void e_die_status(int status, Str* msg, syntax_asdl::loc_t* location = nullptr);


}  // declare namespace pyerror

namespace args {  // declare

extern int String;
extern int Int;
extern int Float;
extern int Bool;
class _Attributes {
 public:
  _Attributes(Dict<Str*, runtime_asdl::value_t*>* defaults);
  void SetTrue(Str* name);
  void Set(Str* name, runtime_asdl::value_t* val);

  GC_OBJ(header_);
  Dict<Str*, runtime_asdl::value_t*>* attrs;
  List<Tuple2<Str*, bool>*>* opt_changes;
  List<Tuple2<Str*, bool>*>* shopt_changes;
  List<Str*>* actions;
  bool show_options;
  bool saw_double_dash;

  static constexpr ObjHeader obj_header() {
    return ObjHeader::ClassScanned(4, sizeof(_Attributes));
  }

  DISALLOW_COPY_AND_ASSIGN(_Attributes)
};

class Reader {
 public:
  Reader(List<Str*>* argv, List<int>* spids = nullptr);
  void Next();
  Str* Peek();
  Tuple2<Str*, int> Peek2();
  Str* ReadRequired(Str* error_msg);
  Tuple2<Str*, int> ReadRequired2(Str* error_msg);
  List<Str*>* Rest();
  Tuple2<List<Str*>*, List<int>*> Rest2();
  bool AtEnd();
  int _FirstSpanId();
  int SpanId();

  GC_OBJ(header_);
  List<Str*>* argv;
  List<int>* spids;
  int n;
  int i;

  static constexpr ObjHeader obj_header() {
    return ObjHeader::ClassScanned(2, sizeof(Reader));
  }

  DISALLOW_COPY_AND_ASSIGN(Reader)
};

class _Action {
 public:
  _Action();
  virtual bool OnMatch(Str* attached_arg, args::Reader* arg_r, args::_Attributes* out);

  GC_OBJ(header_);

  static constexpr ObjHeader obj_header() {
    return ObjHeader::ClassFixed(kZeroMask, sizeof(_Action));
  }

  DISALLOW_COPY_AND_ASSIGN(_Action)
};

class _ArgAction : public _Action {
 public:
  _ArgAction(Str* name, bool quit_parsing_flags, List<Str*>* valid = nullptr);
  virtual runtime_asdl::value_t* _Value(Str* arg, int span_id);
  virtual bool OnMatch(Str* attached_arg, args::Reader* arg_r, args::_Attributes* out);

  Str* name;
  bool quit_parsing_flags;
  List<Str*>* valid;
  
  static constexpr uint16_t field_mask() {
    return maskbit_v(offsetof(_ArgAction, name))
         | maskbit_v(offsetof(_ArgAction, valid));
  }

  static constexpr ObjHeader obj_header() {
    return ObjHeader::ClassFixed(field_mask(), sizeof(_ArgAction));
  }

  DISALLOW_COPY_AND_ASSIGN(_ArgAction)
};

class SetToInt : public _ArgAction {
 public:
  SetToInt(Str* name);
  virtual runtime_asdl::value_t* _Value(Str* arg, int span_id);

  static constexpr ObjHeader obj_header() {
    return ObjHeader::ClassFixed(kZeroMask, sizeof(SetToInt));
  }

  DISALLOW_COPY_AND_ASSIGN(SetToInt)
};

class SetToFloat : public _ArgAction {
 public:
  SetToFloat(Str* name);
  virtual runtime_asdl::value_t* _Value(Str* arg, int span_id);

  static constexpr ObjHeader obj_header() {
    return ObjHeader::ClassFixed(kZeroMask, sizeof(SetToFloat));
  }

  DISALLOW_COPY_AND_ASSIGN(SetToFloat)
};

class SetToString : public _ArgAction {
 public:
  SetToString(Str* name, bool quit_parsing_flags, List<Str*>* valid = nullptr);
  virtual runtime_asdl::value_t* _Value(Str* arg, int span_id);

  static constexpr ObjHeader obj_header() {
    return ObjHeader::ClassFixed(kZeroMask, sizeof(SetToString));
  }

  DISALLOW_COPY_AND_ASSIGN(SetToString)
};

class SetAttachedBool : public _Action {
 public:
  SetAttachedBool(Str* name);
  virtual bool OnMatch(Str* attached_arg, args::Reader* arg_r, args::_Attributes* out);

  Str* name;
  
  static constexpr uint16_t field_mask() {
    return maskbit_v(offsetof(SetAttachedBool, name));
  }

  static constexpr ObjHeader obj_header() {
    return ObjHeader::ClassFixed(field_mask(), sizeof(SetAttachedBool));
  }

  DISALLOW_COPY_AND_ASSIGN(SetAttachedBool)
};

class SetToTrue : public _Action {
 public:
  SetToTrue(Str* name);
  virtual bool OnMatch(Str* attached_arg, args::Reader* arg_r, args::_Attributes* out);

  Str* name;
  
  static constexpr uint16_t field_mask() {
    return maskbit_v(offsetof(SetToTrue, name));
  }

  static constexpr ObjHeader obj_header() {
    return ObjHeader::ClassFixed(field_mask(), sizeof(SetToTrue));
  }

  DISALLOW_COPY_AND_ASSIGN(SetToTrue)
};

class SetOption : public _Action {
 public:
  SetOption(Str* name);
  virtual bool OnMatch(Str* attached_arg, args::Reader* arg_r, args::_Attributes* out);

  Str* name;
  
  static constexpr uint16_t field_mask() {
    return maskbit_v(offsetof(SetOption, name));
  }

  static constexpr ObjHeader obj_header() {
    return ObjHeader::ClassFixed(field_mask(), sizeof(SetOption));
  }

  DISALLOW_COPY_AND_ASSIGN(SetOption)
};

class SetNamedOption : public _Action {
 public:
  SetNamedOption(bool shopt = false);
  void ArgName(Str* name);
  virtual bool OnMatch(Str* attached_arg, args::Reader* arg_r, args::_Attributes* out);

  List<Str*>* names;
  bool shopt;
  
  static constexpr uint16_t field_mask() {
    return maskbit_v(offsetof(SetNamedOption, names));
  }

  static constexpr ObjHeader obj_header() {
    return ObjHeader::ClassFixed(field_mask(), sizeof(SetNamedOption));
  }

  DISALLOW_COPY_AND_ASSIGN(SetNamedOption)
};

class SetAction : public _Action {
 public:
  SetAction(Str* name);
  virtual bool OnMatch(Str* attached_arg, args::Reader* arg_r, args::_Attributes* out);

  Str* name;
  
  static constexpr uint16_t field_mask() {
    return maskbit_v(offsetof(SetAction, name));
  }

  static constexpr ObjHeader obj_header() {
    return ObjHeader::ClassFixed(field_mask(), sizeof(SetAction));
  }

  DISALLOW_COPY_AND_ASSIGN(SetAction)
};

class SetNamedAction : public _Action {
 public:
  SetNamedAction();
  void ArgName(Str* name);
  virtual bool OnMatch(Str* attached_arg, args::Reader* arg_r, args::_Attributes* out);

  List<Str*>* names;
  
  static constexpr uint16_t field_mask() {
    return maskbit_v(offsetof(SetNamedAction, names));
  }

  static constexpr ObjHeader obj_header() {
    return ObjHeader::ClassFixed(field_mask(), sizeof(SetNamedAction));
  }

  DISALLOW_COPY_AND_ASSIGN(SetNamedAction)
};

args::_Attributes* Parse(flag_spec::_FlagSpec* spec, args::Reader* arg_r);
args::_Attributes* ParseLikeEcho(flag_spec::_FlagSpec* spec, args::Reader* arg_r);
args::_Attributes* ParseMore(flag_spec::_FlagSpecAndMore* spec, args::Reader* arg_r);


}  // declare namespace args

#endif  // FRONTEND_ARGS_MYCPP_H
