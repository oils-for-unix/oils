// prebuilt/core/error.mycpp.cc: GENERATED by mycpp

#include "prebuilt/core/error.mycpp.h"
// BEGIN mycpp output

#include "mycpp/runtime.h"

GLOBAL_STR(str0, "(");
GLOBAL_STR(str1, ")");
GLOBAL_STR(str2, "_");
GLOBAL_STR(str3, "T");
GLOBAL_STR(str4, "F");
GLOBAL_STR(str5, "<%s %r>");
GLOBAL_STR(str6, "Invalid type %s: %s");
GLOBAL_STR(str7, "%s != %s: %s");

namespace runtime {  // forward declare


}  // forward declare namespace runtime

namespace runtime {  // declare

using hnode_asdl::hnode;
extern int NO_SPID;
hnode::Record* NewRecord(Str* node_type);
hnode::Leaf* NewLeaf(Str* s, hnode_asdl::color_t e_color);
extern Str* TRUE_STR;
extern Str* FALSE_STR;


}  // declare namespace runtime

namespace runtime {  // define

using hnode_asdl::hnode;
using hnode_asdl::color_t;
using hnode_asdl::color_e;
int NO_SPID = -1;

hnode::Record* NewRecord(Str* node_type) {
  StackRoots _roots({&node_type});

  return Alloc<hnode::Record>(node_type, Alloc<List<hnode_asdl::Field*>>(), false, str0, str1, Alloc<List<hnode_asdl::hnode_t*>>());
}

hnode::Leaf* NewLeaf(Str* s, hnode_asdl::color_t e_color) {
  StackRoots _roots({&s});

  if (s == nullptr) {
    return Alloc<hnode::Leaf>(str2, color_e::OtherConst);
  }
  else {
    return Alloc<hnode::Leaf>(s, e_color);
  }
}
Str* TRUE_STR = str3;
Str* FALSE_STR = str4;

}  // define namespace runtime

namespace error {  // define

using syntax_asdl::loc_e;
using syntax_asdl::loc;
using runtime_asdl::value_t;
using runtime_asdl::value_str;
using mylib::StrFromC;

_ErrorWithLocation::_ErrorWithLocation(Str* msg, syntax_asdl::loc_t* location) {
  this->msg = msg;
  if (location == nullptr) {
    this->location = loc::Missing;
  }
  else {
    this->location = location;
  }
}

bool _ErrorWithLocation::HasLocation() {
  return this->location->tag() != loc_e::Missing;
}

Str* _ErrorWithLocation::UserErrorString() {
  return this->msg;
}

Usage::Usage(Str* msg, syntax_asdl::loc_t* location) : _ErrorWithLocation(msg, location) {
}

Runtime::Runtime(Str* msg) {
  this->msg = msg;
}

Str* Runtime::UserErrorString() {
  return this->msg;
}

Parse::Parse(Str* msg, syntax_asdl::loc_t* location) : _ErrorWithLocation(msg, location) {
}

FailGlob::FailGlob(Str* msg, syntax_asdl::loc_t* location) : _ErrorWithLocation(msg, location) {
}

RedirectEval::RedirectEval(Str* msg, syntax_asdl::loc_t* location) : _ErrorWithLocation(msg, location) {
}

FatalRuntime::FatalRuntime(int exit_status, Str* msg, syntax_asdl::loc_t* location) : _ErrorWithLocation(msg, location) {
  this->exit_status = exit_status;
}

int FatalRuntime::ExitStatus() {
  return this->exit_status;
}

Strict::Strict(Str* msg, syntax_asdl::loc_t* location) : FatalRuntime(1, msg, location) {
}

ErrExit::ErrExit(int exit_status, Str* msg, syntax_asdl::loc_t* location, bool show_code) : FatalRuntime(exit_status, msg, location) {
  this->show_code = show_code;
}

Expr::Expr(Str* msg, syntax_asdl::loc_t* location) : FatalRuntime(3, msg, location) {
}

UserError::UserError(int status, Str* msg, syntax_asdl::loc_t* location) : FatalRuntime(status, msg, location) {
}

InvalidType::InvalidType(Str* msg, syntax_asdl::loc_t* location) : Expr(msg, location) {
}

InvalidType2::InvalidType2(runtime_asdl::value_t* actual_val, Str* msg, syntax_asdl::loc_t* location) : InvalidType(StrFormat("Invalid type %s: %s", StrFromC(value_str(actual_val->tag())), msg), location) {
}

InvalidType3::InvalidType3(runtime_asdl::value_t* left_val, runtime_asdl::value_t* right_val, Str* msg, syntax_asdl::loc_t* location) : InvalidType(StrFormat("%s != %s: %s", StrFromC(value_str(left_val->tag())), StrFromC(value_str(right_val->tag())), msg), location) {
}

[[noreturn]] void e_usage(Str* msg, syntax_asdl::loc_t* location) {
  StackRoots _roots({&msg, &location});

  throw Alloc<Usage>(msg, location);
}

[[noreturn]] void e_strict(Str* msg, syntax_asdl::loc_t* location) {
  StackRoots _roots({&msg, &location});

  throw Alloc<Strict>(msg, location);
}

[[noreturn]] void p_die(Str* msg, syntax_asdl::loc_t* location) {
  StackRoots _roots({&msg, &location});

  throw Alloc<Parse>(msg, location);
}

[[noreturn]] void e_die(Str* msg, syntax_asdl::loc_t* location) {
  StackRoots _roots({&msg, &location});

  throw Alloc<FatalRuntime>(1, msg, location);
}

[[noreturn]] void e_die_status(int status, Str* msg, syntax_asdl::loc_t* location) {
  StackRoots _roots({&msg, &location});

  throw Alloc<FatalRuntime>(status, msg, location);
}

}  // define namespace error

