# args.ysh
#
# Usage:
#   source --builtin args.sh
#
# arg-parse (&spec) {
#   flag -v --verbose (help="Verbosely")  # default is Bool, false
#
#   flag -P --max-procs ('int', default=-1, doc='''
#     Run at most P processes at a time
#     ''')
#
#   flag -i --invert ('bool', default=true, doc='''
#     Long multiline
#     Description
#     ''')
#
#   arg src (help='Source')
#   arg dest (help='Dest')
#   arg times (help='Foo')
#
#   rest files
# }
#
# var opt, i = parseArgs(spec, ARGV)
#
# echo "Verbose $[opt.verbose]"

# TODO: See list
# - It would be nice to keep `flag` and `arg` private, injecting them into the
#   proc namespace only within `Args`

proc arg-parse (; place ; ; block_def) {
  ## Create an args spec which can be passed to parseArgs.
  ##
  ## Example:
  ##
  ##   # NOTE: &spec will create a variable named spec
  ##   arg-parse (&spec) {
  ##     flag -v --verbose ('bool')
  ##   }
  ##
  ##   var flag, i = parseArgs(spec, ARGV)

  var p = {}
  ctx push (p, block_def)

  # Validate that p.rest = [name] or null and reduce p.rest into name or null.
  if ('rest' in p) {
    if (len(p.rest) > 1) {
      error '`rest` was called more than once' (status=3)
    } else {
      setvar p.rest = p.rest[0]
    }
  } else {
    setvar p.rest = null
  }

  var names = {}
  for items in ([p.flags, p.args]) {
    for x in (items) {
      if (x.name in names) {
        error "Duplicate flag/arg name $[x.name] in spec" (status=3)
      }

      setvar names[x.name] = null
    }
  }

  call place->setValue(p)
}

proc flag (short, long ; type='bool' ; default=null, help=null) {
  ## Declare a flag within an `arg-parse`.
  ##
  ## Examples:
  ##
  ##   arg-parse (&spec) {
  ##     flag -v --verbose
  ##     flag -n --count ('int', default=1)
  ##     flag -f --file ('str', help="File to process")
  ##   }

  # TODO: handle only long flag or only short flag
  # TODO: flag aliases

  # Should use "trimPrefix"
  var name = long[2:]

  # TODO: type objects (ie. Bool, Int, Str)
  ctx emit flags ({short, long, name, type, default, help})
}

proc arg (name ; ; default=null, help=null) {
  ## Declare a positional argument within an `arg-parse`.
  ##
  ## Examples:
  ##
  ##   arg-parse (&spec) {
  ##     arg name
  ##     arg config (help="config file path")
  ##     arg out (default="a.out", help="output file path")
  ##   }

  # TODO: need to add required arguments

  ctx emit args ({name, default, help})
}

proc rest (name) {
  ## Take the remaining positional arguments within an `arg-parse`.
  ##
  ## Examples:
  ##
  ##   arg-parse (&grepSpec) {
  ##     arg query
  ##     rest files
  ##   }

  # We emit instead of set to detect multiple invocations of "rest"
  ctx emit rest (name)
}

func parseArgs(spec, argv) {
  ## Given a spec created by `arg-parse`. Parse an array of strings `argv` per
  ## that spec.
  ##
  ## See `arg-parse` for examples of use.

  var i = 0
  var positionalPos = 0
  var argc = len(argv)
  var args = {}
  var rest = []

  var value
  while (i < argc) {
    var arg = argv[i]
    if (arg->startsWith('-')) {
      for flag in (spec.flags) {
        if ( (flag.short and flag.short === arg) or
             (flag.long and flag.long === arg) ) {
          case (flag.type) {
            ('bool') | (null) { setvar value = true }
            int {
              setvar i += 1
              setvar value = int(argv[i])
            }
          }

          setvar args[flag.name] = value
        }
      }
    } elif (positionalPos >= len(spec.args)) {
      if (not spec.rest) {
        error ("Too many arguments, unexpected '$arg'")
      }

      call rest->append(arg)
    } else {
      var pos = spec.args[positionalPos]
      setvar positionalPos += 1
      setvar value = arg
      setvar args[pos.name] = value
    }

    setvar i += 1
  }

  if (spec.rest) {
    setvar args[spec.rest] = rest
  }

  # Set defaults for flags and args
  for flag in (spec.flags) {
    if (flag.name not in args) {
      setvar args[flag.name] = flag.default
    }
  }

  for arg in (spec.args) {
    if (arg.name not in args) {
      setvar args[arg.name] = arg.default
    }
  }

  return ([args, i])
}
