#!/usr/bin/env ysh

module stdlib/synch || return 0

############################
### FIFO File Desriptors ###
############################

func fifo-fd-new() {
  # WARN: this section should be critical but for now it's not
  # A solution may be retry on fail.
  #====================
  var fifo = $(mktemp -u)
  mkfifo $fifo
  #====================
  exec {fd}<>$fifo
  return (fifo)
}

func fifo-fd-destroy(fd) {
  var fifoFile = $(readlink /proc/$$/fd/$fd)
  exec {fd}>-
  exec {fd}<-
  rm $fifoFile
}

#################
### Semaphore ###
#################

func sema-new(value) {
  var sema = fifo-fd-new()
  call sema-up(sema, delta = value)
  return (sema)
}

func sema-down(sema) {
  read <$sema
}

func sema-up(sema; delta = 1) {
  fork {
    for _ in (0 .. delta) {
      echo >$sema
    }
  }
}

func sema-destroy(sema) {
  call fifo-fd-destroy(sema)
}

# NOTE: all synchronization primitives except semaphore and channels are implementation agnostic, meaning we may replace another implementation for semaphore in the future and all other synchronization primitives still work

#############
### Mutex ###
#############

func mutex-new() {
  var mutex = sema-new(1)
  return (mutex)
} 

func mutex-acqure(mutex) {
  call sema-down(mutex)
}

func mutex-release(mutex) {
  call sema-up(mutex)
}

func mutex-destroy(mutex) {
  call sema-destroy(mutex)
}

##############
### RWLock ###
##############
# https://youtu.be/7zI_4CKk-3Y?t=205

func RW-lock-new() {
  return ({
    counter: 0,
    counterLock: mutex-new(),
    writeLock: mutex-new(),
  })
} 

func RW-lock-read(lock) {
  call mutex-acqure(lock.counterLock)
  setvar lock.counter += 1
  if (lock.counter === 1) {
    # First reader should ensure no writer is present
    call mutex-acqure(lock.writeLock)
  }
  call mutex-release(lock.counterLock)
}

func RW-unlock-read(lock) {
  call mutex-acqure(lock.counterLock)
  setvar lock.counter -= 1
  if (lock.counter === 0) {
    # First reader should ensure no writer is present
    call mutex-release(lock.writeLock)
  }
  call mutex-release(lock.counterLock)
}

func RW-lock-write(lock) {
  call mutex-acqure(lock.writeLock)
}

func RW-unlock-write(lock) {
  call mutex-release(lock.writeLock)
}

###############
### Channel ###
###############
func channel-new(...chunks) {
  var chan = fifo-fd-new()
  call channel-produce(chan, ...chunks)
  return (chan)
}

func channel-produce(chan, ...chunks) {
  fork {
    for chunk in (chunks) {
      json write --pretty=F (chunk) >$chan
    }
  }
}

func channel-consume(chan) {
  head -n 1 < $chan | json read (&chunk) 
  return (chunk)
}

func channel-destroy(chan) {
  call fifo-fd-destroy(chan)
}

###########################
### ConditionalVariable ###
###########################
func cond-var-new() {
  var cv = {
    mutex: mutex-new(),
    sema: sema-new(0),
  }
  return (cv)
}

func cond-var-wait(cv) {
  call mutex-release(cv.mutex)
  call sema-down(cv.sema)
  call mutex-acqure(cv.mutex)
}

# WARN: this does not follow the strict semantic of conditional variable, but at least for my case it's usable. 
func cond-var-signal(cv) {
  call sema-up(cv.sema)
}

func cond-var-destroy(cv) {
  call mutex-acqure(cv.mutex)
  call sema-destroy(cv.sema)
  call mutex-destroy(cv.mutex)
}
