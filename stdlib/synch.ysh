#!/usr/bin/env ysh

module stdlib/synch || return 0

############################
### FIFO File Desriptors ###
############################

func fifoFdNew() {
  # WARN: this section should be critical but for now it's not
  # A solution may be retry on fail.
  #====================
  var fifo = $(mktemp -u)
  mkfifo $fifo
  #====================
  exec {fd}<>$fifo
  return (fifo)
}

func fifoFdDestroy(fd) {
  var fifoFile = $(readlink /proc/$$/fd/$fd)
  exec {fd}>-
  exec {fd}<-
  rm $fifoFile
}

#################
### Semaphore ###
#################

func semaNew(value) {
  var sema = fifoFdNew()
  call semaUp(sema, delta = value)
  return (sema)
}

func semaDown(sema) {
  read <$sema
}

func semaUp(sema; delta = 1) {
  {
    for _ in (0 .. delta) {
      echo >$sema
    }
  } &
}

func semaDestroy(sema) {
  call fifoFdDestroy(sema)
}

# NOTE: all synchronization primitives except semaphore and buffers are implementation agnostic, meaning we may replace another implementation for semaphore in the future and all other synchronization primitives still work

#############
### Mutex ###
#############

func mutexNew() {
  var mutex = semaNew(1)
  return (mutex)
} 

func mutexAcquire(mutex) {
  call semaDown(mutex)
}

func mutexRelease(mutex) {
  call semaUp(mutex)
}

func mutexDestroy(mutex) {
  call semaDestroy(mutex)
}

##############
### RWLock ###
##############
# https://youtu.be/7zI_4CKk-3Y?t=205

func RWLockNew() {
  return ({
    counter: 0,
    counterLock: mutexNew(),
    writeLock: mutexNew(),
  })
} 

func RWLockRead(lock) {
  call mutexAcquire(lock.counterLock)
  setvar lock.counter += 1
  if (lock.counter === 1) {
    # First reader should ensure no writer is present
    call mutexAcquire(lock.writeLock)
  }
  call mutexRelease(lock.counterLock)
}

func RWUnLockRead(lock) {
  call mutexAcquire(lock.counterLock)
  setvar lock.counter -= 1
  if (lock.counter === 0) {
    # First reader should ensure no writer is present
    call mutexRelease(lock.writeLock)
  }
  call mutexRelease(lock.counterLock)
}

func RWLockWrite(lock) {
  call mutexAcquire(lock.writeLock)
}

func RWUnLockWrite(lock) {
  call mutexRelease(lock.writeLock)
}

##############
### Buffer ###
##############
# Same as bounded buffer but unbounded
func bufferNew(...chunks) {
  var buf = fifoFdNew()
  {
    for chunk in (chunks) {
      json write --pretty=F (chunk) >$buf
      echo Produced $chunk
    }
  } &
  return (buf)
}

func bufferProduce(buf, chunk) {
  {
    json write --pretty=F (chunk) >$buf
    echo Produced $chunk
  } &
}

func bufferConsume(buf) {
  # BUG: This is broken now as json round-tripping with `--pretty=F` is failing
  head -n 1 < $buf | tr -d '\n' | json read (&chunk) 
  echo Reading $chunk
  return (chunk)
}

func bufferDestroy(buf) {
  call fifoFdDestroy(buf)
}

###########################
### ConditionalVariable ###
###########################
func condVarNew() {
  var cv = {
    mutex: mutexNew(),
    sema: semaNew(0),
  }
  return (cv)
}

func condVarWait(cv) {
  call mutexRelease(cv.mutex)
  call semaDown(cv.sema)
  call mutexAcquire(cv.mutex)
}

# WARN: this does not follow the strict semantic of conditional variable, but at least for my case it's usable. 
func condVarSignal(cv) {
  call semaUp(cv.sema)
  echo Signaling
}

func condVarDestroy(cv) {
  call mutexAcquire(cv.mutex)
  call semaDestroy(cv.sema)
  call mutexDestroy(cv.mutex)
}

# TODO: Channels.
