#!/usr/bin/env ysh

module stdlib/synch || return 0

#################
### Semaphore ###
#################

func semaNew(value) {
  # WARN: this section should be critical but for now it's not
  #====================
  var sema = $(mktemp -u)
  mkfifo $sema
  #====================
  call semaUp(sema, delta = value)
  return (sema)
}

func semaDown(sema) {
  cat $sema > /dev/null
}

func semaUp(sema; delta = 1) {
  {
    for _ in (0 .. delta) {
      echo 1 > $sema
    }
  } &
}

func semaDestroy(sema) {
  rm $sema
}

# NOTE: all synchronization primitives except semaphore is implementation agnostic, meaning we may replace another implementation for semaphore in the future and all other synchronization primitives still work

#############
### Mutex ###
#############

func mutexNew() {
  var mutex = semaNew(1)
  return (mutex)
} 

func mutexAcquire(mutex) {
  call semaDown(mutex)
}

func mutexRelease(mutex) {
  call semaUp(mutex)
}

func mutexDestroy(mutex) {
  call semaDestroy(mutex)
}

#####################
### BoundedBuffer ###
#####################
# https://www.youtube.com/watch?v=Qx3P2wazwI0&t=705s
func boundedBufferNew(capacity, ...jobs) {
  if (len(jobs) >= capacity) {
    echo "Too many jobs ($jobs) to initialize in a job buffer of capacity $capacity!"
    exit 1
  }
  var mutex = semaNew(1)
  var empty = semaNew(capacity - len(jobs))
  var full = semaNew(len(jobs))
  var buf = {
    internal: jobs,
    mutex: mutex,
    empty: empty
    full: full
  }
  return (buf)
}

func boundedBufferProduce(buf, job) {
  call semaDown(buf.empty)
  call mutexAcquire(buf.mutex)
  call buf.internal->append(job)
  call mutexRelease(buf.mutex)
  call semaUp(buf.full)
}

func boundedBufferConsume(buf) {
  call semaDown(buf.full)
  call mutexAcquire(buf.mutex)
  # NOTE: since we semaDown, buf can't be empty
  var ret = buf.internal->pop(job)
  call mutexRelease(buf.mutex)
  call semaUp(buf.empty)
  return (ret)
}

##############
### Buffer ###
##############
# Same as bounded buffer but unbounded
func bufferNew(...jobs) {
  var mutex = semaNew(1)
  var full = semaNew(len(jobs))
  var buf = {
    internal: jobs,
    mutex: mutex,
    full: full
  }
  return (buf)
}

func bufferProduce(buf, job) {
  call mutexAcquire(buf.mutex)
  call buf.internal->append(job)
  call mutexRelease(buf.mutex)
  call semaUp(buf.full)
}

func bufferConsume(buf) {
  call semaDown(buf.full)
  call mutexAcquire(buf.mutex)
  # NOTE: since we semaDown, buf can't be empty
  var ret = buf.internal->pop(job)
  call mutexRelease(buf.mutex)
  return (ret)
}

# TODO: Channels, RWLocks.
