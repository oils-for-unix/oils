#!/usr/bin/env bash
# 
# Make a tarball containing native (C++) code.
#
# Usage:
#   devtools/release-native.sh <function name>

set -o nounset
set -o pipefail
set -o errexit
shopt -s strict:all 2>/dev/null || true  # dogfood for OSH

# adapted from build/ovm-compile.sh
# and devtools/release.sh

OILS_VERSION=$(head -n 1 oils-version.txt)
readonly OILS_VERSION

_gen-shell-build() {
  ### Print shell build script to stdout

  local source_name=${1:-'oils_for_unix'}
  local sh_name=${2:-'_build/oils.sh'}

  local comment="$sh_name: Generated by build/ninja_main.py"
  sed "s;__FILE_COMMENT__;$comment;" build/oils-preamble.sh

  PYTHONPATH=. build/ninja_main.py shell $source_name
}

gen-shell-build() {
  ### Write shell build script

  local source_name=${1:-'oils_for_unix'}
  local sh_name=${2:-'_build/oils.sh'}

  local out=_build/oils.sh
  _gen-shell-build $source_name $sh_name > $sh_name
  chmod +x $sh_name
  echo "  (build/ninja_main.py) -> $sh_name" >&2
}

tarball-manifest() {
  ### Which files should be in the release tarball?

  local source_name=${1:-'oils_for_unix'}
 
  # 100 files
  PYTHONPATH=. build/ninja_main.py tarball-manifest $source_name
}

make-tar() {
  local app_name=${1:-'oils-for-unix'}
  local sh_name=${2:-'_build/oils.sh'}

  local tar=_release/${app_name}.tar

  # NOTE: Could move this to the Makefile, which will make it
  mkdir -p _release 

  local source_name=${app_name//'-'/'_'}  # oils_for_unix
  gen-shell-build $source_name $sh_name

  # Build source code
  ninja _gen/bin/$source_name.{mycpp,mycpp-souffle}.cc

  local sed_expr="s,^,${app_name}-${OILS_VERSION}/,"
  tarball-manifest $source_name \
    | xargs -- tar --create --transform "$sed_expr" --file $tar

  local tar_gz=_release/${app_name}-${OILS_VERSION}.tar.gz
  gzip -c $tar > $tar_gz

  ls -l _release
}

test-tar() {
  local install=${1:-}
  local translator=${2:-mycpp}

  local tmp=_tmp/native-tar-test  # like oil-tar-test
  rm -r -f $tmp
  mkdir -p $tmp
  cd $tmp
  tar -x < ../../_release/oils-for-unix.tar

  pushd oils-for-unix-$OILS_VERSION
  build/native.sh tarball-demo $translator

  if test -n "$install"; then
    sudo ./install
  fi

  popd
}

test-install-tar() {
  ### test that sudo ./install works

  # This is run in the raw-vm soil task
  test-tar T
}

#
# hello app
#

make-hello-tar() {
  make-tar hello _build/oils.sh

  # TODO:
  # - turn tar into zip file
  # - bin/hello should #includee mycpp/gc_list.h only?
  # - test it on Windows
}

test-hello-tar() {
  local zip="$PWD/_release/hello-$OILS_VERSION.zip"

  local tmp=_tmp/hello-tar-test  # like oil-tar-test
  rm -r -f $tmp
  mkdir -p $tmp

  cd $tmp
  tar -x < ../../_release/hello.tar
  zip -r $zip .

  pushd hello-$OILS_VERSION

  ./configure
  _build/oils.sh

  set +o errexit
  _bin/cxx-opt-sh/hello a b c
  echo "hello status=$?"
  set -o errexit

  popd
}

#
# More
#

extract-for-benchmarks() {
  local install=${1:-}

  local tar=$PWD/_release/oils-for-unix.tar
  local dest='../benchmark-data/src'
  mkdir -p $dest

  pushd $dest
  git pull
  tar -x < $tar

  # For benchmarks
  pushd oils-for-unix-$OILS_VERSION

  # Remove binaries left over from old attempts
  rm -v _bin/cxx-{dbg,opt}-sh/* || true

  ./configure

  # devtools/release.sh also has this DWARF 4 hack, for bloaty
  for variant in dbg opt; do
    CXXFLAGS=-gdwarf-4 _build/oils.sh --variant "$variant"
  done

  build/native.sh tarball-demo

  if test -n "$install"; then
    sudo ./install
  fi
  popd

  git add oils-for-unix-$OILS_VERSION

  git status
  echo "Now run git commit"

  popd
}

#
# Repro bug #1731 -- passing duplicate files to tar results in weird hard
# links!
#

install-bsdtar() {
  sudo apt-get install libarchive-tools
}

test-with-bsdtar() {
  pushd _release
  bsdtar -x < oils-for-unix.tar
  popd
}

"$@"
