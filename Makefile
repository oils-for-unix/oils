# Build OVM App Bundles (Python code with a statically-linked CPython
# interpreter.)
#
# We can also build a tarball that allows the end user to build an app bundle.
# They need GNU Make, bash, and a C compiler.  (And xargs, chmod, etc.)
#
# Tarball layout (see build/compile.sh for details):
#
# oil.tar/
#   configure
#   install
#   Makefile
#   _build/                 # Intermediate files
#     oil/                  # The app name
#       bytecode-opy.zip        # Arch-independent
#       main_name.c
#       module_init.c       # Python module initializer
#       c-module-srcs.txt   # List of Modules/ etc.
#   native/                 # App-specific modules
#     libc.c
#   build/
#     static-c-modules.txt  # From Python interpreter
#     compile.sh ...
#     detect-cc.c ...
#   Python-2.7.13/
#     pyconfig.h            # A frozen version
#     Python/
#     Objects/
#     Modules/
#     Include/
#
#
# Intermediate layout:
#
# _build/
#   cpython-full/           # Full CPython build, for dynamically
#                           # discovering Python/C dependencies
#   c-module-toc.txt        # What files each module is in
#   py-to-compile.txt
#   runpy-deps-c.txt
#   runpy-deps-cpython.txt
#   runpy-deps-opy.txt
#   oil/                    # App-specific dir
#     py-to-compile.txt
#     all-deps-c.txt        # App deps plus CPython platform deps
#     app-deps-cpython.txt  # compiled with CPython
#     opy-app-deps.txt      # compiled with OPy, does NOT match app-deps-% !
#     bytecode-cpython.zip
#     bytecode-opy.zip
#     c-module-srcs.txt
#     main_name.c
#     module_init.c
#     ovm.d                 # Make fragment
#     ovm, ovm-dbg          # OVM executables (without bytecode)
# _release/
#   oil.tar                 # See tarball layout above
# _bin/                     # Concatenated App Bundles
#   oil.ovm
#   oil.ovm-dbg
#   hello.ovm
#   hello.ovm-dbg

# Needed for rules with '> $@'.  Does this always work?
.DELETE_ON_ERROR:

# Intermediate targets aren't automatically deleted.
.SECONDARY:

# Don't use the built-in rules database.  This makes the 'make -d' output
# easier to read.
.SUFFIXES:

# Make all directories before every build.  There might be a nicer way of
# handling directories but I don't know it.
# NOTE: _devbuild is made by build/dev.sh.  That directory is NOT cleaned with
# 'make clean'.
$(shell mkdir -p _bin _release _tmp _build/hello _build/oil _build/gen)

ACTIONS_SH := build/actions.sh
COMPILE_SH := build/compile.sh

# For faster tesing of builds
#default: _bin/oil.ovm-dbg

# What the end user should build when they type 'make'.
default: _bin/oil.ovm

# Debug bundles and release tarballs.
all: \
	_bin/hello.ovm _bin/oil.ovm \
	_bin/hello.ovm-dbg _bin/oil.ovm-dbg \
	_release/hello.tar _release/oil.tar

# For the release tarball.
clean:
	$(ACTIONS_SH) clean-source-tarball-build

# For developers in a repo.
clean-repo:
	$(ACTIONS_SH) clean-repo

.PHONY: default all clean install

# NOTES:
# - Manually rm this file to generate a new build timestamp.
# - This messes up reproducible builds.
# - It's not marked .PHONY because that would mess up the end user build.
#   bytecode.zip should NOT be built by the user.
_build/release-date.txt:
	$(ACTIONS_SH) write-release-date

# The Makesfiles generated by autoconf don't call configure, but Linux/toybox
# config system does.  This can be overridden.
_build/detected-config.sh:
	./configure

# .PHONY alias for compatibility
install:
	@./install

# What files correspond to each C module.
# TODO:
# - Where to put -l z?  (Done in Modules/Setup.dist)
_build/c-module-toc.txt: build/c_module_toc.py
	$(ACTIONS_SH) c-module-toc > $@

# Python and C dependencies of runpy.
# NOTE: This is done with a pattern rule because of the "multiple outputs"
# problem in Make.
_build/runpy-deps-%.txt: build/runpy_deps.py
	$(ACTIONS_SH) runpy-deps _build

_build/py-to-compile.txt: build/runpy_deps.py
	$(ACTIONS_SH) runpy-py-to-compile > $@

#
# Hello App.  Everything below here is app-specific.
#

# C module dependencies
-include _build/hello/ovm.d

# What Python module to run.
_build/hello/main_name.c:
	$(ACTIONS_SH) main-name hello hello.ovm > $@

# Dependencies calculated by importing main.  The guard is because ovm.d
# depends on it.  Is that correct?  We'll skip it before 'make dirs'.
_build/hello/app-deps-%.txt: $(HELLO_SRCS) \
	_build/detected-config.sh build/app_deps.py
	test -d _build/hello && \
	  $(ACTIONS_SH) app-deps hello build/testdata hello

_build/hello/py-to-compile.txt: \
	_build/detected-config.sh build/app_deps.py
	test -d _build/hello && \
	  $(ACTIONS_SH) py-to-compile build/testdata hello > $@

# NOTE: We could use src/dest paths pattern instead of _build/app?
#
# TODO:
# - Deps need to be better.  Depend on .pyc and .py.    I guess
#   app-deps hello will compile the .pyc files.  Don't need a separate action.
#   %.pyc : %py

HELLO_BYTECODE_DEPS := \
	build/testdata/hello-version.txt \
        _build/release-date.txt \
	build/testdata/hello-manifest.txt

_build/hello/bytecode-cpython.zip: $(HELLO_SRCS) $(HELLO_BYTECODE_DEPS) \
                           _build/hello/app-deps-cpython.txt \
                           _build/runpy-deps-cpython.txt
	{ echo 'build/testdata/hello-version.txt hello-version.txt'; \
	  echo '_build/release-date.txt release-date.txt'; \
	  cat build/testdata/hello-manifest.txt \
	      _build/hello/app-deps-cpython.txt \
	      _build/runpy-deps-cpython.txt; \
	} | build/make_zip.py $@

_build/hello/bytecode-opy.zip: $(HELLO_SRCS) $(HELLO_BYTECODE_DEPS) \
                           _build/hello/opy-app-deps.txt
	{ echo 'build/testdata/hello-version.txt hello-version.txt'; \
	  echo '_build/release-date.txt release-date.txt'; \
	  cat build/testdata/hello-manifest.txt \
	      _build/hello/opy-app-deps.txt; \
	} | build/make_zip.py $@

#
# Oil
#

# C module dependencies
-include _build/oil/ovm.d

_build/oil/main_name.c:
	$(ACTIONS_SH) main-name bin.oil oil.ovm > $@

# The root of this repo, e.g. ~/git/oil, should be our PYTHONPATH for
# detecting dependencies.
# 
# From this link:
# https://stackoverflow.com/questions/322936/common-gnu-makefile-directory-path
# Except we're using 'firstword' instead of 'lastword', because
# _build/oil/ovm.d is the last one.
REPO_ROOT := $(abspath $(dir $(firstword $(MAKEFILE_LIST))))

# Dependencies calculated by importing main.
# NOTE: The list of files is used both to compile and to make a tarball.
# - For compiling, we should respect _HAVE_READLINE in detected_config
# - For the tarball, we should ALWAYS include readline.
#
# BUG: Running 'make' the first time files because it can't find the '_build'
# package.  build/doc.sh currently makes _build/__init__.py.
_build/oil/app-deps-%.txt: _build/detected-config.sh build/app_deps.py
	test -d _build/oil && \
	  $(ACTIONS_SH) app-deps oil $(REPO_ROOT) bin.oil

_build/oil/py-to-compile.txt: _build/detected-config.sh build/app_deps.py
	test -d _build/oil && \
	  $(ACTIONS_SH) py-to-compile $(REPO_ROOT) bin.oil > $@

_build/osh_help.py: doc/osh-quick-ref-pages.txt
	build/doc.sh osh-quick-ref

# TODO: Need $(OIL_SRCS) here?
# NOTES:
# - _build/osh_help.py is a minor hack to depend on the entire
# _build/osh-quick-ref dir, since they both get generated by the same build
# action.
# - release-date is at a different location on purpose, so we don't show it in
#   dev mode.

OIL_BYTECODE_DEPS := \
	oil-version.txt \
	_build/release-date.txt \
	build/oil-manifest.txt \
	_build/osh_help.py \
	doc/osh-quick-ref-toc.txt

_build/oil/bytecode-cpython.zip: $(OIL_BYTECODE_DEPS) \
                         _build/oil/app-deps-cpython.txt \
                         _build/runpy-deps-cpython.txt
	{ echo '_build/release-date.txt release-date.txt'; \
	  $(ACTIONS_SH) files-manifest oil-version.txt \
	                               doc/osh-quick-ref-toc.txt; \
	  cat build/oil-manifest.txt \
	      _build/oil/app-deps-cpython.txt \
	      _build/runpy-deps-cpython.txt; \
	  $(ACTIONS_SH) quick-ref-manifest _build/osh-quick-ref; \
	} | build/make_zip.py $@ 

# NOTE: runpy deps are inncluded in opy-app-deps.txt.
_build/oil/bytecode-opy.zip: $(OIL_BYTECODE_DEPS) \
                         _build/oil/opy-app-deps.txt
	{ echo '_build/release-date.txt release-date.txt'; \
	  $(ACTIONS_SH) files-manifest oil-version.txt \
	                               doc/osh-quick-ref-toc.txt; \
	  cat build/oil-manifest.txt \
	      _build/oil/opy-app-deps.txt; \
	  $(ACTIONS_SH) quick-ref-manifest _build/osh-quick-ref; \
	} | build/make_zip.py $@ 

#
# App-Independent Pattern Rules.
#

# Regenerate dependencies.  But only if we made the app dirs.
_build/%/ovm.d: _build/%/app-deps-c.txt
	$(ACTIONS_SH) make-dotd $* $^ > $@

# Source paths of all C modules the app depends on.  For the tarball.
# A trick: remove the first dep to form the lists.  You can't just use $^
# because './c_module_srcs.py' is rewritten to 'c_module_srcs.py'.
_build/%/c-module-srcs.txt: \
	build/c_module_srcs.py _build/c-module-toc.txt _build/%/app-deps-c.txt
	build/c_module_srcs.py $(filter-out $<,$^) > $@

_build/%/all-deps-c.txt: build/static-c-modules.txt _build/%/app-deps-c.txt
	$(ACTIONS_SH) join-modules $^ > $@

# NOTE: This should really depend on all the .py files.
# I should make a _build/oil/py.d file and include it?
_build/%/opy-app-deps.txt: \
	_build/py-to-compile.txt _build/%/py-to-compile.txt
	sort $^ | uniq | opy/build.sh compile-manifest _build/%-with-opy > $@


PY27 := Python-2.7.13

# Per-app extension module initialization.
_build/%/module_init.c: $(PY27)/Modules/config.c.in _build/%/all-deps-c.txt
	# NOTE: Using xargs < input.txt style because it will fail if input.txt
	# doesn't exist!  'cat' errors will be swallowed.
	xargs $(ACTIONS_SH) gen-module-init < _build/$*/all-deps-c.txt > $@


# 
# Tarballs
#
# Contain Makefile and associated shell scripts, discovered .c and .py deps,
# app source.

_release/%.tar: _build/%/bytecode-cpython.zip \
                _build/%/module_init.c \
                _build/%/main_name.c \
                _build/%/c-module-srcs.txt
	$(COMPILE_SH) make-tar $* $@

#
# Native Builds
#

# Release build.
# This depends on the static modules
_build/%/ovm: _build/%/module_init.c _build/%/main_name.c \
              _build/%/c-module-srcs.txt $(COMPILE_SH)
	$(COMPILE_SH) build-opt $@ $(filter-out $(COMPILE_SH),$^)

# Fast build, with symbols for debugging.
_build/%/ovm-dbg: _build/%/module_init.c _build/%/main_name.c \
                  _build/%/c-module-srcs.txt $(COMPILE_SH)
	$(COMPILE_SH) build-dbg $@ $(filter-out $(COMPILE_SH),$^)

# Coverage, for paring down the files that we build.
# TODO: Hook this up.
_build/%/ovm-cov: _build/%/module_init.c _build/%/main_name.c \
                  _build/%/c-module-srcs.txt $(COMPILE_SH)
	$(COMPILE_SH) build $@ $(filter-out $(COMPILE_SH),$^)

# Make bundles quickly.
_bin/%.ovm-dbg: _build/%/ovm-dbg _build/%/bytecode-cpython.zip
	cat $^ > $@
	chmod +x $@

_bin/%.ovm: _build/%/ovm _build/%/bytecode-cpython.zip
	cat $^ > $@
	chmod +x $@

# For debugging
print-%:
	@echo $*=$($*)
